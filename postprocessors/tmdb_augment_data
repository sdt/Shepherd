#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use LWP::UserAgent;
use XMLTV;

use lib 'references';
use Shepherd::json_pp qw( );

my $progname = "tmdb_augment_data";
my $version = "0.01";
my $script_start_time = time;
my %stats;

my $opt = {
    api_key                 => $ENV{TMDB_API_KEY},
    output_file             => "output.xmltv",
    cache_file              => "$0.storable.cache",
    lang                    => "en",
    debug                   => 0,
    min_duration            => 65, # 65 mins
    max_duration            => 240,
    skip_categories         =>
        'Infotainment,Shopping,Business and Finance,Game Show,News,' .
        'Parliament,Current Affairs,sports,Sport,Weather,Reality,live,' .
        'Talk Show,Lifestyle',
    dont_augment_desc       => 1, # from 2008/04/15
};

GetOptions(
    'region=i'             => \$opt->{region},             #  ignored
    'days=i'               => \$opt->{days},               #  ignored
    'offset=i'             => \$opt->{offset},             #  ignored
    'timezone=s'           => \$opt->{timezone},           #  ignored
    'channels_file=s'      => \$opt->{channels_file},      #  ignored
    'config-file=s'        => \$opt->{configfile},         #  ignored

    'min_duration=i'       => \$opt->{min_duration},
    'max_duration=i'       => \$opt->{max_duration},
    'skip_categories=s'    => \$opt->{skip_categories},
    'cache_details_for=i'  => \$opt->{cache_details_for},
    'cache_title_for=i'    => \$opt->{cache_title_for},
    'long-info'            => \$opt->{long_info},
    'dont-augment-desc=i'  => \$opt->{dont_augment_desc},
    'output=s'             => \$opt->{output_file},
    'cache-file=s'         => \$opt->{cache_file},
    'fast'                 => \$opt->{fast},
    'no-cache'             => \$opt->{no_cache},
    'debug+'               => \$opt->{debug},
    'lang=s'               => \$opt->{lang},
    'no-retry'             => \$opt->{dont_retry},
    'help'                 => \$opt->{help},
    'test=s'               => \$opt->{test},
    'simpletest=s'         => \$opt->{simpletest},
    'set=s'                => \$opt->{set},
    'verbose'              => \$opt->{help},
    'version'              => \$opt->{version},
    'ready'                => \$opt->{ready},
    'desc'                 => \$opt->{desc},
    'v'                    => \$opt->{version},
);

my $tmdb = PostProcessor::TMDBAugmentData->new($opt);
$tmdb->run(@ARGV);
undef $tmdb;

Shepherd::Common::print_stats($progname, $version, $script_start_time, %stats);

exit;

sub make_accessors {
    my ($class, @fields) = @_;

    no strict 'refs';
    for my $accessor (@fields) {
        *{ $class . '::' . $accessor } = sub { return $_[0]->{$accessor} }
    }
}

#-------------------------------------------------------------------------------

package PostProcessor::TMDBAugmentData;
use URI::Escape qw( uri_escape );

sub new {
    my ($class, $opt) = @_;

    my $fh = new IO::File(">".$opt->{output_file})
        or die "can't open $opt->{output_file} for writing: $!";

    my $self = {
        opt => $opt,
        ua  => UserAgent::Cached->new($opt->{cache_file}),
        uri => 'http://api.themoviedb.org/2.1/Movie.search/en/json/'
             . $opt->{api_key} . '/',
        writer => new XMLTV::Writer(
            encoding => 'ISO-8859-1',
            OUTPUT => $fh,
        ),
        skip_category => {
            map { lc($_) => 1 } split(/,/, $opt->{skip_categories})
        },
    };

    ::make_accessors($class, keys %$self);
    return bless $self, $class;
}

sub run {
    my ($self, @files) = @_;

    $self->writer->start( {
        'source-info-url' => "http://themoviedb.org",
        'source-info-name' => "$progname $version",
        'generator-info-name' => "$progname $version",
    } );

    for my $file (@files) {
        Shepherd::Common::log(sprintf("Parsing: %s",
            ($file eq "-" ? "(from-stdin, hit control-D to finiah)" : $file)));
        XMLTV::parsefiles_callback(undef, undef,
            sub { $self->channel_cb(@_) },
            sub { $self->programme_cb(@_) }, $file);
    }

    $self->writer->end();
    Shepherd::Common::log("Finished parsing, output in $opt->{output_file}");

    $self->ua->save_cache;

    return 1;
}

sub channel_cb {
    my ($self, $channel) = @_;
    $self->writer->write_channel($channel);
}

sub programme_cb {
    my ($self, $prog) = @_;
    $self->augment_programme($prog);
    $self->writer->write_programme($prog);
}

sub augment_programme {
    my ($self, $prog) = @_;

    return unless $self->check_title($prog);
	return unless $self->check_category($prog);
	return unless $self->check_duration($prog);

    $self->movie_search($prog);

	$stats{included_for_imdb_lookup}++;
}

sub check_title {
    my ($self, $prog) = @_;

    my $title = get_programme_field($prog->{title});
	if ($title =~ /^(station )?close$/i) {
		$stats{skipped_due_to_category}++;
		return;
    }
    return 1;
}

sub check_category {
    my ($self, $prog) = @_;
    return 1 unless $prog->{category};
    my @categories = map { lc $_->[0] } @{ $prog->{category} };

    # If one of the categories is movie(s), include it.
    return 1 if grep { /^movies?$/ } @categories;

    # If it is a skip category, exclude it.
    my $skip = $self->skip_category;
    return if grep { $skip->{$_} } @categories;

    # If we get here, include it.
    return 1;
}

sub check_duration {
    my ($self, $prog) = @_;
	my $start = Shepherd::Common::parse_xmltv_date($prog->{start});
	my $end   = Shepherd::Common::parse_xmltv_date($prog->{stop});
	if (!$start || !$end) {
		$stats{excluded_couldnt_parse_time}++;
		return;
	}
	my $duration = (($end - $start) / 60);
	if ($duration < $self->opt->{min_duration}) {
		$stats{excluded_prog_too_short}++;
        return;
	}
	if ($duration > $self->opt->{max_duration}) {
		$stats{excluded_prog_too_long}++;
		return;
	}
    return 1;
}

sub get_programme_field {
    my ($field) = @_;
    return unless $field && $field->[0] && $field->[0]->[0];
    return $field->[0]->[0];
}

my %dumped;
sub movie_search {
    my ($self, $prog) = @_;

    my $title = lc get_programme_field($prog->{title});
    my $uri = $self->uri . uri_escape($title);

    my $year = $prog->{date};
    if ($year) {
        $uri .= "+$year";
    }

    my $resp = $self->ua->get($uri);
    return unless $resp->is_success;

    my $data = JSON::cut_down_PP::decode_json($resp->content);
    if (!$data) {
        $stats{found_no_data}++;
        return;
    }
    if (ref $data ne 'ARRAY') {
        $stats{found_unexpected_format}++;
        return;
    }

    if (ref $data->[0] ne 'HASH') {
        $stats{found_none}++;
        return;
    }

    if (@$data == 1) {
        $stats{found_one}++;
        return $data->[0];
    }

    my @exact_matches = grep { lc $_->{name} eq $title } @$data;
    if (@exact_matches == 1) {
        $stats{found_one_title}++;
        return $exact_matches[0];
    }

    $stats{found_multiple}++;

#    return if $dumped{$uri};
#    use Data::Dumper::Concise;
#    map { delete $_->{backdrops}; delete $_->{posters} } @$data;
#    print Dumper([$uri, [ map { $_->{name} } @$data ], $prog, $data]), "\n";
#    $dumped{$uri} = 1;
}

#-------------------------------------------------------------------------------

package UserAgent::Cached;

use lib 'references';
use Shepherd::Common qw();

sub new {
    my ($class, $filename) = @_;

    my $self = {
        cache    => Shepherd::Common::read_cache($filename),
        filename => $filename,
        ua       => LWP::UserAgent->new,
    };

    ::make_accessors($class, keys %$self);
    return bless $self, $class;
}

sub get {
    my ($self, $uri) = @_;

    my $res = $self->cache->{$uri};
    if ($res) {
        if ($res->is_fresh) {
            print STDERR "CACHE  HIT on $uri\n";
            $stats{cache_hits}++;
            return $res;
        }
        else {
            print STDERR "CACHE EXPIRED on $uri\n";
            $stats{cache_expiries}++;
        }
    }
    else {
        print STDERR "CACHE miss on $uri\n";
        $stats{cache_misses}++;
    }
    $res = $self->cache->{$uri} = $self->ua->get($uri);
    #$self->save_cache;
    return $res;
}

sub save_cache {
    my ($self) = @_;

    my $cache = $self->cache;
    my @expired_cache_entries =
        grep { ! $cache->{$_}->is_fresh } keys %$cache;
    delete $cache->{$_} for @expired_cache_entries;
    Shepherd::Common::write_cache($self->filename, $cache);
}

1;
